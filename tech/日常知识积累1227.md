## 泛化调用

泛化调用就是服务消费者端因为某种原因并没有该服务接口，这个原因有很多，比如是跨语言的，一个PHP工程师想调用某个java接口，他并不能按照你约定，去写一个个的接口，Dubbo并不是跨语言的RPC框架，但并不是不能解决这个问题，这个PHP程序员搭建了一个简单的java web项目，引入了dubbo的jar包，使用dubbo的泛化调用，然后利用web返回json，这样也能完成跨语言的调用。泛化调用的好处之一就是这个了。

简而言之，泛化调用，最最直接的表现就是服务消费者不需要有任何接口的实现，就能完成服务的调用

## maven依赖问题

### 依赖调节

当依赖众多时，经常出现的一个问题就是相同依赖的不同版本通过依赖传递被引入进来。Maven采用就近原则来解决版本不一致问题。就近原则指的是在Maven依赖树中离项目最近的那个版本。比如A通过依赖传递依赖了两个版本的D：

- A -> B -> C -> D 2.0
- A -> E -> D 1.0 那么D1.0会被Maven选择，因为D1.0距离A的层级更少。

### 依赖管理

在POM中的dependencyManagement区块中直接申明依赖的版本，依赖传递的版本会被dependencyManagement区块中申明的版本所取代

### 依赖范围

Maven在编译时会用一套classpath，跑测试时有另一套classpath。而实际运行时，又是新一套classpath。依赖范围就是用来控制依赖与这三套classpath的关系。Maven有如下几种依赖范围：

- compile：默认依赖范围，不申明的话就为compile，对于编译、测试、运行三种classpath都有效。
- test：只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。
- provided：对于编译和测试classpath有效，但在运行时无效。典型例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。
- runtime：对于测试和运行classpath有效，但在编译主代码时无效。典型例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。
- system：和provided依赖范围完全一致。但使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。